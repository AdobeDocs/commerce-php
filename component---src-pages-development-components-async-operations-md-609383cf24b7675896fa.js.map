{"version":3,"file":"component---src-pages-development-components-async-operations-md-609383cf24b7675896fa.js","mappings":"oRAQaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,gBAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAHgC,WACjCC,GAEC,EADEC,GACF,YACD,OAAO,SAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,wCACH,yCACL,kBAAK,iLAEL,kBAAK,iGAA+F,uBAAYC,WAAW,KAAM,qBAAkC,mJAEnK,eACE,GAAM,qBACH,sBACL,mBAAG,uBAAYA,WAAW,KAAM,gDAA6D,sBAC7F,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,uLAWP,kBAAK,+CAA6C,uBAAYA,WAAW,KAAM,SAAsB,oDACvG,uBAAYA,WAAW,KAAM,YAAyB,wDACpD,kBAAK,uDAAqD,uBAAYA,WAAW,KAAM,qBAAkC,yCACzH,oBACE,eAAIA,WAAW,MAAO,sDAAoD,uBAAYA,WAAW,MAAO,SAAsB,4DAC9H,eAAIA,WAAW,MAAO,8BAA4B,uBAAYA,WAAW,MAAO,SAAsB,6FAExG,kBAAK,sIAC6C,uBAAYA,WAAW,KAAM,0DAAuE,MACtJ,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,2YAeP,kBAAK,iFACL,eACE,GAAM,eACH,gBACL,kBAAK,kBAAgB,uBAAYA,WAAW,KAAM,YAAyB,MAAI,uBAAYA,WAAW,KAAM,YAAyB,SAAO,uBAAYA,WAAW,KAAM,YAAyB,kGAClM,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,mhBAeP,kBAAK,iCACL,kBAAK,kLACL,eACE,GAAM,wBACH,yBACL,kBAAK,kOACqD,uBAAYA,WAAW,KAAM,uCAAoD,6GAE3I,kBAAK,iBACL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,y8BA8BP,eACE,GAAM,qDACH,sDACL,kBAAK,6GACP,uBAAYA,WAAW,KAAM,qBAAkC,2GAAyG,uBAAYA,WAAW,KAAM,SAAsB,aACzN,kBAAK,yEACL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,g6CAiEP,kBAAK,8IAC8B,uBAAYA,WAAW,KAAM,qBAAkC,iCAA+B,uBAAYA,WAAW,KAAM,oBAAiC,iDAA+C,uBAAYA,WAAW,KAAM,SAAsB,gBACjS,eACE,GAAM,mDACH,oDACL,kBAAK,6IACL,kBAAK,gBACL,kBAAK,gSAEL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,65DAsEP,eACE,GAAM,YACH,aACL,kBAAK,qCAAmC,uBAAYA,WAAW,KAAM,kDAA+D,SAAO,uBAAYA,WAAW,KAAM,sCAAmD,kBAAgB,uBAAYA,WAAW,KAAM,4DAAyE,gCAA8B,uBAAYA,WAAW,KAAM,qBAAkC,gDAGjb,CAEDJ,EAAWK,gBAAiB,C","sources":["webpack://commerce-php/./src/pages/development/components/async-operations.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/commerce-php/commerce-php/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"asynchronous-and-deferred-operations\"\n    }}>{`Asynchronous and deferred operations`}</h1>\n    <p>{`Asynchronous operations are not native to PHP but it is still possible to execute heavy\noperations simultaneously, or delay them until they absolutely have to be finished.`}</p>\n    <p>{`To make writing asynchronous code easier, Adobe Commerce and Magento Open Source provide the `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` to use with asynchronous operations.\nThis allows client code to work with asynchronous operations just as it would with standard operations.`}</p>\n    <h2 {...{\n      \"id\": \"deferredinterface\"\n    }}>{`DeferredInterface`}</h2>\n    <p><inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Async\\\\DeferredInterface`}</inlineCode>{` is quite simple:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`interface DeferredInterface\n{\n    /**\n     * @return mixed Value.\n     * @throws \\\\Throwable\n     */\n    public function get();\n\n    public function isDone(): bool;\n}\n`}</code></pre>\n    <p>{`When the client code needs the result, the `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` method will be called to retrieve the result.\n`}<inlineCode parentName=\"p\">{`isDone()`}</inlineCode>{` can be used to see whether the code has completed.`}</p>\n    <p>{`There are 2 types of asynchronous operations where `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to describe the result:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`With asynchronous operations in progress, calling `}<inlineCode parentName=\"li\">{`get()`}</inlineCode>{` would wait for them to finish and return their result.`}</li>\n      <li parentName=\"ul\">{`With deferred operations, `}<inlineCode parentName=\"li\">{`get()`}</inlineCode>{` would actually start the operation, wait for it to finish, and then return the result.`}</li>\n    </ul>\n    <p>{`Sometimes developers require more control over long asynchronous operations.\nThat is why there is an extended deferred variant - `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Async\\\\CancelableDeferredInterface`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`interface CancelableDeferredInterface extends DeferredInterface\n{\n    /**\n     * @param bool $force Cancel operation even if it's already started.\n     * @return void\n     * @throws CancelingDeferredException When failed to cancel.\n     */\n    public function cancel(bool $force = false): void;\n\n    /**\n     * @return bool\n     */\n    public function isCancelled(): bool;\n}\n`}</code></pre>\n    <p>{`This interface is for operations that may take too long and can be canceled.`}</p>\n    <h3 {...{\n      \"id\": \"client-code\"\n    }}>{`Client code`}</h3>\n    <p>{`Assuming that `}<inlineCode parentName=\"p\">{`serviceA`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`serviceB`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`serviceC`}</inlineCode>{` all execute asynchronous operations, such as HTTP requests, the client code would look like:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function aMethod() {\n    //Started executing 1st operation\n    $operationA = $serviceA->executeOp();\n\n    //Executing 2nd operations at the same time\n    $operationB = $serviceB->executeOp2();\n\n    //We need to wait for 1st operation to start operation #3\n    $serviceC->executeOp3($operationA->get());\n\n    //We don't have to wait for operation #2, let client code wait for it if it needs the result\n    //Operation number #3 is being executed simultaneously with operation #2\n    return $operationB;\n}\n`}</code></pre>\n    <p>{`And not a callback in sight!`}</p>\n    <p>{`With the deferred client, the code can start multiple operations at the same time, wait for operations required to finish and pass the promise of a result to another method.`}</p>\n    <h2 {...{\n      \"id\": \"proxydeferredfactory\"\n    }}>{`ProxyDeferredFactory`}</h2>\n    <p>{`When writing a module or an extension, you may not want to burden other developers with having to know that your method is performing an asynchronous operation.\nThere is a way to hide it: employ the autogenerated factory `}<inlineCode parentName=\"p\">{`YourClassName\\\\ProxyDeferredFactory`}</inlineCode>{`. With its help, you can return values that seem like regular objects\nbut are in fact deferred results.`}</p>\n    <p>{`For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function __construct(CallResult\\\\ProxyDeferredFactory $callResultFactory)\n{\n    $this->proxyDeferredFactory = $callResultFactory;\n}\n\n....\n\npublic function doARemoteCall(string $uniqueValue): CallResult\n{\n    //Async HTTP request, get() will return a CallResult instance.\n    //Call is in progress.\n    $deferredResult = $this->client->call($uniqueValue);\n\n    //Returns CallResult instance that will call $deferredResult->get() when any of the object's methods is used.\n    return $this->proxyDeferredFactory->create(['deferred' => $deferredResult]);\n}\n\npublic function doCallsAndProcess(): Result\n{\n    //Both calls running simultaneously\n    $call1 = $this->doARemoteCall('call1');\n    $call2 = $this->doARemoteCall('call2');\n\n    //Only when CallResult::getStuff() is called the $deferredResult->get() is called.\n    return new Result([\n        'call1' => $call1->getStuff(),\n        'call2' => $call2->getStuff()\n    ]);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"using-deferredinterface-for-background-operations\"\n    }}>{`Using DeferredInterface for background operations`}</h2>\n    <p>{`As mentioned above, the first type of asynchronous operations are operations executing in a background.\n`}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to give client code a promise of a not-yet-received result and wait for it by calling the `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` method.`}</p>\n    <p>{`Take a look at an example: creating shipments for multiple products:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class DeferredShipment implements DeferredInterface\n{\n    private $request;\n\n    private $done = false;\n\n    private $trackingNumber;\n\n    public function __construct(AsyncRequest $request)\n    {\n        $this->request = $request;\n    }\n\n    public function isDone() : bool\n    {\n        return $this->done;\n    }\n\n    public function get()\n    {\n        if (!$this->trackingNumber) {\n            $this->request->wait();\n            $this->trackingNumber = json_decode($this->request->getBody(), true)['tracking'];\n\n            $this->done = true;\n        }\n\n        return $this->trackingNumber;\n    }\n}\n\nclass Shipping\n{\n    ....\n\n    public function ship(array $products): array\n    {\n        $shipments = [];\n        //Shipping simultaneously\n        foreach ($products as $product) {\n            $shipments[] = new DeferredShipment(\n                $this->client->sendAsync(['id' => $product->getId()])\n            );\n        }\n\n        return $shipments;\n    }\n}\n\nclass ShipController\n{\n    ....\n\n    public function execute(Request $request): Response\n    {\n        $shipments = $this->shipping->ship($this->products->find($request->getParam('ids')));\n        $trackingsNumbers = [];\n        foreach ($shipments as $shipment) {\n            $trackingsNumbers[] = $shipment->get();\n        }\n\n        return new Response(['trackings' => $trackingNumbers]);\n    }\n}\n`}</code></pre>\n    <p>{`Here, multiple shipment requests are being sent at the same time with their results gathered later.\nIf you do not want to write your own `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` implementation, you can use `}<inlineCode parentName=\"p\">{`CallbackDeferred`}</inlineCode>{` to provide callbacks that will be used when `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` is called.`}</p>\n    <h2 {...{\n      \"id\": \"using-deferredinterface-for-deferred-operations\"\n    }}>{`Using DeferredInterface for deferred operations`}</h2>\n    <p>{`The second type of asynchronous operations are operations that are being postponed and executed only when a result is absolutely needed.`}</p>\n    <p>{`An example:`}</p>\n    <p>{`Assume you are creating a repository for an entity and you have a method that returns a singular entity by ID.\nYou want to make a performance optimization for cases when multiple entities are requested during the same request-response process, so you would not load them separately.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class EntityRepository\n{\n    private $requestedEntityIds = [];\n\n    private $identityMap = [];\n\n    ...\n\n    /**\n     * @return Entity[]\n     */\n    public function findMultiple(array $ids): array\n    {\n        .....\n\n        //Adding found entities to the identity map be able to find them by ID.\n        foreach ($found as $entity) {\n            $this->identityMap[$entity->getId()] = $entity;\n        }\n\n        ....\n    }\n\n    public function find(string $id): Entity\n    {\n        //Adding this ID to the list of previously requested IDs.\n        $this->requestedEntityIds[] = $id;\n\n        //Returning deferred that will find all requested entities\n        //and return the one with $id\n        return $this->proxyDeferredFactory->createFor(\n            Entity::class,\n            new CallbackDeferred(\n                function () use ($id) {\n                    if (empty($this->identityMap[$id])) {\n                        $this->findMultiple($this->requestedEntityIds);\n                        $this->requestedEntityIds = [];\n                    }\n\n                    return $this->identityMap[$id];\n                }\n            )\n        );\n    }\n\n    ....\n}\n\nclass EntitiesController\n{\n    ....\n\n    public function execute(): Response\n    {\n        //No actual DB query issued\n        $criteria1Id = $this->entityService->getEntityIdWithCriteria1();\n        $criteria2Id = $this->entityService->getEntityIdWithCriteria2();\n        $criteria1Entity = $this->entityRepo->find($criteria1Id);\n        $criteria2Entity = $this->entityRepo->find($criteria2Id);\n\n        //Querying the DB for both entities only when getStringValue() is called the 1st time.\n        return new Response(\n            [\n                'criteria1' => $criteria1Entity->getStringValue(),\n                'criteria2' => $criteria2Entity->getStringValue()\n            ]\n        );\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"examples\"\n    }}>{`Examples`}</h2>\n    <p>{`See our asynchronous HTTP client `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\HTTP\\\\AsyncClientInterface`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Magento\\\\Shipping\\\\Model\\\\Shipping`}</inlineCode>{` with various `}<inlineCode parentName=\"p\">{`Magento\\\\Shipping\\\\Model\\\\Carrier\\\\AbstractCarrierOnline`}</inlineCode>{` implementations to see how `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to work with asynchronous code.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}