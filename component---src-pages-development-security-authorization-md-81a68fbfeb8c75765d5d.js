"use strict";(self.webpackChunkcommerce_php=self.webpackChunkcommerce_php||[]).push([[6239],{37845:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return l},default:function(){return p}});var a=t(58168),i=t(80045),o=(t(88763),t(15680)),r=t(83407);const s=["components"],l={},d={_frontmatter:l},c=r.A;function p(e){let{components:n}=e,t=(0,i.A)(e,s);return(0,o.mdx)(c,(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"authorization"},"Authorization"),(0,o.mdx)("h2",{id:"configuration-based-authorization"},"Configuration-based authorization"),(0,o.mdx)("p",null,"Through configuration, Adobe Commerce and Magento Open Source provide a number of ways to mark a page (controller) or an endpoint as accessible to guests, logged in customers, or administrators with roles that allow access to certain resources."),(0,o.mdx)("h3",{id:"pages-controllers"},"Pages (controllers)"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Distinction by user type"),(0,o.mdx)("p",{parentName:"li"},"To make a page accessible to customers (both guests and registered) coming from storefront, place a controller\nin the ",(0,o.mdx)("inlineCode",{parentName:"p"},"<Vendor>\\\\<Module>\\\\Controller\\\\**")," namespace."),(0,o.mdx)("p",{parentName:"li"},"To make a page accessible only to administrators, place a controller in the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<Vendor>\\\\<Module>\\\\Controller\\\\Adminhtml\\\\**")," namespace.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Requiring specific resource access for administrators"),(0,o.mdx)("p",{parentName:"li"},"Each administrator is assigned an ACL role that provides them access only to selected resources.\nTo mark your page (route/controller) as one that requires access to a specific resource, the controller\nmust extend ",(0,o.mdx)("inlineCode",{parentName:"p"},"Magento\\Backend\\App\\Action")," and override the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ADMIN_RESOURCE")," constant with the name of the resource."))),(0,o.mdx)("h3",{id:"restfulsoap-web-api-endpoints"},"RESTful/SOAP web API endpoints"),(0,o.mdx)("p",null,"RESTful/SOAP web API endpoints are configured in a module's ",(0,o.mdx)("inlineCode",{parentName:"p"},"webapi.xml")," configuration file. An endpoint is defined as\na ",(0,o.mdx)("inlineCode",{parentName:"p"},"route")," tag and authorization for each is configured by ",(0,o.mdx)("inlineCode",{parentName:"p"},"resource")," tags in ",(0,o.mdx)("inlineCode",{parentName:"p"},"routes.route.resources")," path."),(0,o.mdx)("p",null,"Endpoints can be configured to be accessible by specific users as follows:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"For guest customer access:\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<resource>anonymous</resource>"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"For authenticated customers:\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<resource>self</resource>"))),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"For administrators or 3rd-party integration clients by one or multiple ",(0,o.mdx)("inlineCode",{parentName:"p"},"resource")," tags:\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<resource>Module_Name::resource1</resource>"),"\n",(0,o.mdx)("inlineCode",{parentName:"p"},"<resource>Module_Name::resource2</resource>")))),(0,o.mdx)("h3",{id:"ui-components"},"UI components"),(0,o.mdx)("p",null,"To mark UI components as accessible by customers or administrators, place the UI component XML config files\nin the ",(0,o.mdx)("inlineCode",{parentName:"p"},"<Module>/view/**")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"<Module>/view/adminhtml/**")," folders, respectively."),(0,o.mdx)("p",null,"To require specific ACL resource access for administrators, UI component tags allow ",(0,o.mdx)("inlineCode",{parentName:"p"},"aclResource")," tags and attributes\naccepting string values with resource names such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"Module_Name::resource"),"."),(0,o.mdx)("p",null,"It is important to provide a ",(0,o.mdx)("inlineCode",{parentName:"p"},"aclResource")," configuration when a UI component (or data provider)\nexposes sensitive information, since any UI component can be rendered on its own through ",(0,o.mdx)("inlineCode",{parentName:"p"},"mui/render")," without\ngoing through a controller first."),(0,o.mdx)("h2",{id:"explicit-authorization"},"Explicit authorization"),(0,o.mdx)("p",null,"However, some cases cannot be covered by configuration. Authorization must be verified explicitly."),(0,o.mdx)("h3",{id:"page-controller-for-authenticated-customers"},"Page (controller) for authenticated customers"),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"UserContextInterface")," can be utilized to verify that a customer has logged in:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-php"},"class MyController implements \\Magento\\Framework\\App\\ActionInterface, \\Magento\\Framework\\App\\Action\\HttpGetActionInterface {\n    private \\Magento\\Authorization\\Model\\UserContextInterface $userContext;\n    ...\n    public function construct(\\Magento\\Authorization\\Model\\UserContextInterface $userContext) {\n        $this->userContext = $userContext;\n    }\n    ...\n\n    public function execute() {\n        ...\n\n        if ($this->userContext->getUserType() == UserContextInterface::USER_TYPE_CUSTOMER\n            && $this->userContext->getUserId()) {\n            ...\n        } else {\n            throw new AuthorizationException(__('Please log in'));\n        }\n    }\n}\n")),(0,o.mdx)("h3",{id:"graphql-node-for-authenticated-customers"},"GraphQL node for authenticated customers"),(0,o.mdx)("p",null,"A ",(0,o.mdx)("inlineCode",{parentName:"p"},"Magento\\GraphQl\\Model\\Query\\ContextInterface")," instance is always available for GraphQL resolvers and can help with authorizing customers."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-php"},"class MyResolver implements \\Magento\\Framework\\GraphQl\\Query\\ResolverInterface\n{\n    ...\n    public function resolve(\n        Field $field,\n        $context,\n        ResolveInfo $info,\n        array $value = null,\n        array $args = null\n    ) {\n        /** @var \\Magento\\GraphQl\\Model\\Query\\ContextInterface $context */\n        if (false === $context->getExtensionAttributes()->getIsCustomer()) {\n            throw new GraphQlAuthorizationException(__('The current customer isn\\'t authorized.'));\n        }\n        ...\n    }\n}\n")),(0,o.mdx)("h3",{id:"ownership-verification"},"Ownership verification"),(0,o.mdx)("p",null,"There are cases when you want to limit read/write access to information to a user who owns the related entities.\nFor instance, customers must have access only to their own wishlists. When serving this type of information or accepting an update,\nmanual verification is required."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-php"},"if ($userContext->getUserType() === UserContextInterface::USER_TYPE_CUSTOMER\n    && $userContext->getUserId() === $wishListItem->getCustomerId()) {\n    return $wishListItem;\n} else {\n    throw new AuthorizationException(__('Not authorized'));\n}\n")),(0,o.mdx)("h3",{id:"explicit-authorization-in-blocks-and-ui-component-data-providers"},"Explicit authorization in blocks and UI component data providers"),(0,o.mdx)("p",null,"When explicit authorization is required for tasks such as ownership verification, it is important to remember\nthat blocks and UI components can be used with different controllers or rendered on their own."),(0,o.mdx)("p",null,"Consider the example above: you have a page that is supposed to display a specific wishlist. The URL for this page\nhas a required parameter ",(0,o.mdx)("inlineCode",{parentName:"p"},"wishlist_id"),". Inside the controller, you verify ownership before moving forward with\nrendering. But, inside the block or the UI component data provider that is supposed to fetch the wishlist data and\nrender it, you simply find the data by ID. This particular page will be protected but when the UI component is rendered independently\nthrough ",(0,o.mdx)("inlineCode",{parentName:"p"},"/mui/render"),", or when the block is used on a different page with a different controller, no ownership authorization will occur,\nand any wishlist data may be retrieved through the ID."),(0,o.mdx)("h2",{id:"temporal-authorization"},"Temporal authorization"),(0,o.mdx)("p",null,"There are cases where it is either impossible to authorize a user via login/password, or access to a resource must\nbe issued temporarily. For instance, when a protected page needs to be accessible from an e-mail link immediately without\nrequiring the user to have a valid session or go through sign-up/login. For situations such as this, a self-signed token with a\nlimited lifespan can be utilized. Self-signed tokens have advantages over randomized secrets stored in the database in that you do not\nhave to store them and maintain their lifespan. They can be verified without accessing storage and the TTL information that is embedded inside of them."),(0,o.mdx)("p",null,'Let\'s take the "page accessible from e-mail" example. Imagine that there is a requirement to remind customers that have\nnot finished registration to complete the process. Your store needs to send such customers an e-mail with a link\nto a sign-up form with fields containing previously entered information. These customers cannot login, and it cannot be\nexpected for them to have the same session cookie when they follow the e-mail link. This issue can be solved by\nembedding a self-signed token inside the link that contains the "unfinished sign up data" ID and expiration datetime\nto protect the token from brute force attack. Then when customer follows the link, the store would verify its\nsignature or decrypt it, verify that token has not yet expired, and then pre-fill the form with customer data retrieved from\nthe database by ID. If the form is not too big, then it would be possible to even avoid storing data in persistent storage, but\ninstead embed it inside the token itself using an encrypted token to protect sensitive data.'),(0,o.mdx)("p",null,"When the only client of a self-signed token is the application itself, it is not absolutely necessary to follow\na certain standard when generating self-signed tokens, but it would be easier and more secure to utilize one, like JWT.\nThe application framework provides a tool to help with this process. See ",(0,o.mdx)("inlineCode",{parentName:"p"},"Magento\\Framework\\Jwt\\JwtManagerInterface"),"\nand its usage within Magento Open Source."),(0,o.mdx)("p",null,"An example of using ",(0,o.mdx)("inlineCode",{parentName:"p"},"JwtManagerInterface")," for the e-mail link case above:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-php"},"class FinishSignUpTokenManager {\n  ...\n\n  private JwtManagerInterface $jwtManager;\n\n  private EncryptionSettingsInterface $jwtEncSettings;\n\n  private string $secret;\n\n  public function construct(JwtManagerInterface $jwtManager, JwkFactory $jwtFactory, string $secret) {\n    $this->jwtManager = $jwtManager;\n    //Configure JWT encryption settings\n    $this->jwtEncSettings = new JweEncryptionJwks(\n      $jwkFactory->createA128KW($secret),\n      JweEncryptionSettingsInterface::CONTENT_ENCRYPTION_ALGO_A128_HS256\n    );\n  }\n\n  public function generate(SignUpFormData $data): string {\n    //Embed signUp data array into JWT claims\n    $jwt = new Jwe(\n      new JweHeader([]),\n      new ClaimsPayload(\n        [\n          new PrivateHeaderParameter('signup-data', $data->getData()),\n          new ExpirationTime((new \\DateTimeImmutable())->add(new \\DateInterval('P7D')))\n        ]\n      )\n    );\n\n    return $this->jwtManager->create($jwt, $this->jwtEncSettings);\n  }\n\n  public function readToken(string $token): SignUpFormData\n  {\n    $jwt = $this->jwtManager->read($token, $this->jwtEncSettings);\n    /** @var ClaimsPayloadInterface $payload */\n    $payload = $jwt->getPayload();\n    if ($payload instanceof ClaimsPayloadInterface) {\n      if (((int) $payload->getClaims()['exp']->getValue()) <= time()) {\n        throw new LocalizedException(__('Token expired'));\n      }\n\n      return new SignUpFormData($payload->getClaims()['signup-data']->getValue());\n    } else {\n      throw new LocalizedException(__('Invalid token'));\n    }\n  }\n}\n\nclass FinishSignUpNotifier {\n  ...\n\n  private FinishSignUpTokenManager $tokenManager;\n\n  ...\n\n  public function notify(SignUpFormData $data) {\n    ...\n\n    //Generating link for E-mails\n    $link .= '?token=' .$this->tokenManager->generate($data);\n\n    ...\n  }\n}\n\nclass SignUp implements ActionInterface, HttpPostActionInterface {\n  ...\n\n  private FinishSignUpTokenManager $tokenManager;\n\n  ...\n\n  public function execute() {\n    //Retrieving previously filled data from token inside the controller to display SignUp form\n    try {\n      $signUpPrefilled = $this->tokenManager->readToken($this->request->getParam('token'));\n    } catch (LocalizedException $ex) {\n      $signUpPrefilled = null;\n      $this->messages->addWarning($ex->getPhrase());\n    }\n\n    ...\n  }\n}\n")))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-development-security-authorization-md-81a68fbfeb8c75765d5d.js.map