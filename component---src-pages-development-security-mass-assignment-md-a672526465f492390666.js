"use strict";(self.webpackChunkcommerce_php=self.webpackChunkcommerce_php||[]).push([[8616],{9359:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return l},default:function(){return c}});var a=t(87462),r=t(45987),i=(t(35776),t(3905)),s=t(91515);const o=["components"],l={},d={_frontmatter:l},p=s.Z;function c(e){let{components:n}=e,t=(0,r.Z)(e,o);return(0,i.mdx)(p,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"mass-assignment"},"Mass assignment"),(0,i.mdx)("p",null,"Mass assignment is a type of attack in which a client inserts or updates data that either should not be available to the user, or should require additional authorization."),(0,i.mdx)("p",null,"For example, you have an endpoint or a page where users can edit their personal information. The user table in your database contains the following columns:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"id")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"first_name")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"last_name")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"email")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"password_hash")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_admin"))),(0,i.mdx)("p",null,"You want users to be able to edit their first and last names only on a page or through the endpoint, but inside the controller/service contract, you have code that looks something like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-php"},"$user = $repository->findById($authContext->getUserId());\n$user->setData($request->getPostData());\n$dbConnection->updateTable('users', $user->getData(), ['id' => $user->getId()]);\n")),(0,i.mdx)("p",null,"When a client only provides ",(0,i.mdx)("inlineCode",{parentName:"p"},"first_name")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"last_name")," properties, this code will perform as expected, but it is vulnerable to mass assignment attacks."),(0,i.mdx)("p",null,"The first vulnerability is through the ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," property. Users are meant to be able to edit only their own data, but here an attacker can set an ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," in their request. The",(0,i.mdx)("inlineCode",{parentName:"p"},"$user")," object's ID will be overwritten, so when you call ",(0,i.mdx)("inlineCode",{parentName:"p"},"$dbConnection->updateTable()"),", instead of having the ID from ",(0,i.mdx)("inlineCode",{parentName:"p"},"$authContext"),", you will have an arbitrary ID from the HTTP request. This will allow an attacker to override data of any user in your system!"),(0,i.mdx)("p",null,"The second possible vulnerability is through the ",(0,i.mdx)("inlineCode",{parentName:"p"},"is_admin")," property. Clearly, the property was meant to be writable only by other admins, and maybe even by using another page/endpoint. Using the code above, an attacker can set ",(0,i.mdx)("inlineCode",{parentName:"p"},'"is_admin": true')," inside a request and gain admin access when you save the user record."),(0,i.mdx)("p",null,"Given the ",(0,i.mdx)("inlineCode",{parentName:"p"},"users")," table structure, and depending on your application's logic, ",(0,i.mdx)("inlineCode",{parentName:"p"},"email")," can also be a vulnerable property. An attacker might be able to change their email to any other address without confirming it first."),(0,i.mdx)("h2",{id:"mass-assignment-and-the-commerce-framework"},"Mass assignment and the Commerce framework"),(0,i.mdx)("p",null,"If you are not careful and, especially, if you use the legacy approach described below, it is easy to make yourself vulnerable to mass assignment."),(0,i.mdx)("h3",{id:"legacy-approach"},"Legacy approach"),(0,i.mdx)("p",null,"The legacy approach of exposing data to be writable by users means having a controller that uses\n",(0,i.mdx)("inlineCode",{parentName:"p"},"Magento\\Framework\\Model\\AbstractModel")," and sets request data directly, instead of doing so with a DTO\nand a service contract."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-php"},"class Save extends \\Magento\\Backend\\App\\Action implements HttpPostActionInterface\n{\n    ...\n\n\n    public function execute()\n    {\n        $data = $this->getRequest()->getPostValue();\n        /** @var MyModel $model */\n        $model = $this->modelFactory->create()\n            ->load($this->getRequest()->getParam('id'));\n        $model->setData($data);\n        $model->save();\n\n        return $this->generateRedirect();\n    }\n}\n")),(0,i.mdx)("p",null,"As you can see, this example is similar to the generic example with users before. We take all data from the request,\nthus allowing the client to override ANY property that the model (table) has and then store it."),(0,i.mdx)("h3",{id:"newer-approach"},"Newer approach"),(0,i.mdx)("p",null,"A more recent practice is to have service contracts and DTOs that are directly exposed as REST APIs, used inside related\ncontrollers and GraphQL resolvers."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-xml"},'<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Api/etc/extension_attributes.xsd">\n    <extension_attributes for="\\MyStore\\MyModule\\Api\\Data\\User">\n        <attribute code="is_admin" type="boolean" />\n    </extension_attributes>\n</config>\n\n<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">\n    <route url="/V1/users" method="PUT">\n        <service class="MyStore\\MyModule\\Api\\UserManagerInterface" method="save"/>\n        <resources>\n            <resource ref="self"/>\n        </resources>\n    </route>\n</routes>\n')),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-php"},"interface UserInterface extends ExtensibleDataInterface\n{\n    public function getId(): int;\n    public function getFirstName(): string;\n    public function getLastName(): string;\n    public function getEmail(): string;\n    public function getPasswordHash(): string;\n    public function getExtensionAttributes(): \\MyStore\\MyModule\\Api\\Data\\UserExtensionInterface;\n    public function setExtensionAttributes(\\MyStore\\MyModule\\Api\\Data\\UserExtensionInterface $extensionAttributes): void;\n}\n\nclass UserModel extends AbstractModel implements UserInterface\n{\n    ...\n}\n\ninterface UserManagerInterface\n{\n    public function save(\\MyStore\\MyModule\\Api\\Data\\UserInterface $user): \\MyStore\\MyModule\\Api\\Data\\UserInterface;\n}\n\nclass Save extends \\Magento\\Framework\\App\\Action\\Action implements HttpPostActionInterface\n{\n    ...\n\n    /**\n     * @var DataObjectHelper\n     */\n    private $dataObjectHelper;\n\n    /**\n     * @var UserManagerInterface\n     */\n    private $manager;\n\n    ...\n\n    public function execute()\n    {\n        $data = $this->getRequest()->getPostValue();\n        /** @var UserInterface|UserModel $user */\n        $user = $this->repo->findById($this->userContext->getUserId());\n        //hydration\n        $this->dataObjectHelper->populateWithArray($user, $data, UserInterface::class);\n\n        //Saving\n        $this->manager->save($user);\n\n        return $this->generateRedirect();\n    }\n}\n")),(0,i.mdx)("p",null,"In this example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInterface")," is the DTO for the operation, and ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserManagerInterface")," is the service contract. From\nthe XML snippet above, you can see that the ",(0,i.mdx)("inlineCode",{parentName:"p"},"isAdmin")," property is added to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInterface")," DTO as an extension attribute.\nYou can also see that ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserManagerInterface::save()")," can be invoked directly by accessing the REST endpoint\n",(0,i.mdx)("inlineCode",{parentName:"p"},"PUT /V1/users"),". We also use the service contract inside the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Save")," controller, which handles a page that enables a user to edit personal info."),(0,i.mdx)("p",null,"This approach is better because we do not accept all data coming from client request blindly, but rather only those properties\nstrictly defined inside ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInterface")," with getters. For REST APIs, this is ensured by the application framework automatically,\nand inside the controller, we hydrate the user object retrieved from the DB with ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataObjectHelper"),"."),(0,i.mdx)("p",null,"However, because our DTO is also implemented by a class that extends ",(0,i.mdx)("inlineCode",{parentName:"p"},"AbstractModel"),", it's a de facto active record\nof the ",(0,i.mdx)("inlineCode",{parentName:"p"},"users")," table. As a result, we still have the issue where we exposed the ",(0,i.mdx)("inlineCode",{parentName:"p"},"id"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"is_admin"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"email")," properties.\nThe same vulnerabilities persist."),(0,i.mdx)("h2",{id:"solution"},"Solution"),(0,i.mdx)("p",null,"The vulnerability can be fixed relatively easily by having a strict list of properties accepted by your\ncontrollers/service contracts that do not necessarily correlate with the storage schema.\nThis can be achieved by using operation-specific DTOs instead of persistence-layer DTOs."),(0,i.mdx)("p",null,"Example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-xml"},'<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">\n    <route url="/V1/users" method="PUT">\n        <service class="MyStore\\MyModule\\Api\\UserManagerInterface" method="update"/>\n        <resources>\n            <resource ref="self"/>\n        </resources>\n        <data>\n            \x3c!-- Enforcing UpdatedUserDataInterface::getId() to always equal to current user\'s ID --\x3e\n            <parameter name="user.id" force="true">%user_id%</parameter>\n        </data>\n    </route>\n</routes>\n')),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-php"},"interface UpdatedUserDataInterface extends ExtensibleDataInterface\n{\n    //This property will be enforced by controller/webapi\n    public function getId(): int;\n    //Only having properties that you wish to be writable by users themselves\n    public function getFirstName(): string;\n    public function getLastName(): string;\n    public function getExtensionAttributes(): \\MyStore\\MyModule\\Api\\Data\\UpdatedUserDataExtensionInterface;\n    public function setExtensionAttributes(\\MyStore\\MyModule\\Api\\Data\\UpdatedUserDataExtensionInterface $extensionAttributes): void;\n}\n\n//Read-only DTO\ninterface UserInfoInterface extends ExtensibleDataInterface\n{\n    public function getId(): int;\n    public function getFirstName(): string;\n    public function getLastName(): string;\n    public function getEmail(): string;\n    public function getExtensionAttributes(): \\MyStore\\MyModule\\Api\\Data\\UserInfoExtensionInterface;\n    public function setExtensionAttributes(\\MyStore\\MyModule\\Api\\Data\\UserInfoExtensionInterface $extensionAttributes): void;\n}\n\n//Notice the implementation extending simple DataObject instead of the model.\nclass UpdatedUserData extends DataObject implements UpdatedUserDataInterface\n{\n    ...\n}\n\ninterface UserManagerInterface\n{\n    public function update(\\MyStore\\MyModule\\Api\\Data\\UpdatedUserDataInterface $user): \\MyStore\\MyModule\\Api\\Data\\UserInfoInterface;\n}\n\nclass Save extends \\Magento\\Framework\\App\\Action\\Action implements HttpPostActionInterface\n{\n    ...\n\n    /**\n     * @var DataObjectHelper\n     */\n    private $dataObjectHelper;\n\n    /**\n     * @var UserManagerInterface\n     */\n    private $manager;\n\n    ...\n\n    public function execute()\n    {\n        $data = $this->getRequest()->getPostValue();\n        //Enforcing user ID.\n        $data['id'] = $this->userContext->getUserId();\n        $updatedData = new UpdatedUserData();\n        //hydration\n        $this->dataObjectHelper->populateWithArray($updatedData, $data, UpdatedUserDataInterface::class);\n\n        //Saving\n        $this->manager->update($updatedData);\n\n        return $this->generateRedirect();\n    }\n}\n")),(0,i.mdx)("p",null,"You can see that ",(0,i.mdx)("inlineCode",{parentName:"p"},"UpdatedUserDataInterface")," only contains properties that we want users to be able to\nupdate. It is not an ",(0,i.mdx)("inlineCode",{parentName:"p"},"AbstractModel"),", but rather a simple data container (",(0,i.mdx)("inlineCode",{parentName:"p"},"DataObject"),"), so we won't have to add any\nnew properties, even if we add new columns to the table. We'll only update ",(0,i.mdx)("inlineCode",{parentName:"p"},"UpdatedUserDataInterface")," explicitly\nwhen we want to make a property writeable by clients."),(0,i.mdx)("p",null,"However, we still have\n",(0,i.mdx)("inlineCode",{parentName:"p"},"getId")," as a part of the DTO in order to identify which user to update. That means that we need to ensure that the\nproperty will contain the value we want, and not a user defined value. For REST APIs, we achieve this with the ",(0,i.mdx)("inlineCode",{parentName:"p"},"parameter"),"\ntag, which will find a registered ",(0,i.mdx)("inlineCode",{parentName:"p"},"ParamOverrider")," and use it to override whatever the client has provided. In the controller,\nwe do this by explicitly setting ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," as current user ID."),(0,i.mdx)("p",null,"Note that ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserManagerInterface")," returns ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInfoInterface"),", which is another DTO, and not an ",(0,i.mdx)("inlineCode",{parentName:"p"},"AbstractModel"),".\nIt serves a similar purpose: to expose only the properties to clients that we want them to see. This example does not contain\n",(0,i.mdx)("inlineCode",{parentName:"p"},"getPasswordHash()"),", for instance."),(0,i.mdx)("h3",{id:"authorization"},"Authorization"),(0,i.mdx)("p",null,"In the example above, we skipped the ",(0,i.mdx)("inlineCode",{parentName:"p"},"isAdmin()")," user property. We don't want users to access this property themselves,\nbut we do want this property to be writeable by other admin users."),(0,i.mdx)("p",null,"The best solution here would be to have a separate service, controller, and DTOs meant for admin users that would expose\nmore properties like ",(0,i.mdx)("inlineCode",{parentName:"p"},"isAdmin()")," with the endpoints/pages requiring authorization to related resources."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-xml"},'<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">\n    <route url="/V1/admin/users" method="PUT">\n        <service class="MyStore\\MyModule\\Api\\AdminUserManagerInterface" method="save"/>\n        <resources>\n            <resource ref="Magento_User::manage"/>\n        </resources>\n    </route>\n</routes>\n')),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-php"},"interface UserFullDataInterface extends ExtensibleDataInterface\n{\n    //Properties we wish admins have access to\n    public function getId(): int;\n    public function getFirstName(): string;\n    public function getLastName(): string;\n    public function isAdmin(): bool;\n    public function isActive(): bool;\n    public function getExtensionAttributes(): \\MyStore\\MyModule\\Api\\Data\\UserFullDataExtensionInterface;\n    public function setExtensionAttributes(\\MyStore\\MyModule\\Api\\Data\\UserFullDataExtensionInterface $extensionAttributes): void;\n}\n\n\n//Read-only DTO\ninterface FullUserInfoInterface extends ExtensibleDataInterface\n{\n    public function getId(): int;\n    public function getFirstName(): string;\n    public function getLastName(): string;\n    public function getEmail(): string;\n    public function isAdmin(): boolean;\n    public function isActive(): string;\n    public function getExtensionAttributes(): \\MyStore\\MyModule\\Api\\Data\\FullUserInfoExtensionInterface;\n    public function setExtensionAttributes(\\MyStore\\MyModule\\Api\\Data\\FullUserInfoExtensionInterface $extensionAttributes): void;\n}\n\n//Notice the implementation extending simple DataObject instead of the model.\nclass UserFullData extends DataObject implements UserFullDataInterface\n{\n    ...\n}\n\ninterface AdminUserManagerInterface\n{\n    public function save(\\MyStore\\MyModule\\Api\\Data\\UserFullDataInterface $user): \\MyStore\\MyModule\\Api\\Data\\FullUserInfoInterface;\n}\n\nclass Save extends \\Magento\\Backend\\App\\Action implements HttpPostActionInterface\n{\n    ...\n\n    const ADMIN_RESOURCE = 'Magento_User::manage';\n\n    /**\n     * @var DataObjectHelper\n     */\n    private $dataObjectHelper;\n\n    /**\n     * @var AdminUserManagerInterface\n     */\n    private $manager;\n\n    ...\n\n    public function execute()\n    {\n        $data = $this->getRequest()->getPostValue();\n        $userData = new UserFullData();\n        //hydration\n        $this->dataObjectHelper->populateWithArray($userData, $data, UserFullDataInterface::class);\n\n        //Saving\n        $this->manager->save($userData);\n\n        return $this->generateRedirect();\n    }\n}\n")),(0,i.mdx)("p",null,"Notice how both the endpoint and the controller now require authorization for ",(0,i.mdx)("inlineCode",{parentName:"p"},"Magento_User::manage"),". In an earlier example,\nwe had ",(0,i.mdx)("inlineCode",{parentName:"p"},"isAdmin()")," property added to ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInterface")," as an extension attribute. If we have the same DTOs\nfor operations that require additional authorization and those that do not, we risk other extensions exposing\nvulnerable data. With this approach, another extension can decide to only add certain properties to DTOs available\nonly to admin users by providing extension attributes for ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserFullDataInterface")," only."),(0,i.mdx)("h3",{id:"graphql"},"GraphQL"),(0,i.mdx)("p",null,"For GraphQL APIs, the application does not rely on interfaces to generate schema. Instead, we have explicit GraphQL schemas, and there is\nno risk of exposing fields accidentally when you update data storage schema. However, if for some reason some fields\ndo require additional authorization, you would still need to verify it explicitly."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-development-security-mass-assignment-md-a672526465f492390666.js.map