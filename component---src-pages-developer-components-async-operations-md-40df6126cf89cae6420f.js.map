{"version":3,"file":"component---src-pages-developer-components-async-operations-md-40df6126cf89cae6420f.js","mappings":"8QAQaA,EAAe,GACtBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,SAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,mMAEA,mHAAoG,uBAAYC,WAAW,KAAvB,qBAApG,mJAEA,eACE,GAAM,qBADR,sBAGA,mBAAG,uBAAYA,WAAW,KAAvB,gDAAH,sBACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,uLAaL,iEAAkD,uBAAYA,WAAW,KAAvB,SAAlD,oDACF,uBAAYA,WAAW,KAAvB,YADE,wDAEA,yEAA0D,uBAAYA,WAAW,KAAvB,qBAA1D,yCACA,oBACE,eAAIA,WAAW,MAAf,sDAA0E,uBAAYA,WAAW,MAAvB,SAA1E,4DACA,eAAIA,WAAW,MAAf,8BAAkD,uBAAYA,WAAW,MAAvB,SAAlD,6FAEF,wJACkD,uBAAYA,WAAW,KAAvB,0DADlD,MAEA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,2YAiBL,mGACA,eACE,GAAM,eADR,gBAGA,oCAAqB,uBAAYA,WAAW,KAAvB,YAArB,MAA+E,uBAAYA,WAAW,KAAvB,YAA/E,SAA4I,uBAAYA,WAAW,KAAvB,YAA5I,kGACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,mhBAiBL,mDACA,oMACA,eACE,GAAM,wBADR,yBAGA,oPAC0D,uBAAYA,WAAW,KAAvB,uCAD1D,6GAGA,mCACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,y8BAgCL,eACE,GAAM,qDADR,sDAGA,+HACF,uBAAYA,WAAW,KAAvB,qBADE,2GACsK,uBAAYA,WAAW,KAAvB,SADtK,aAEA,2FACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,g6CAmEL,gKACmC,uBAAYA,WAAW,KAAvB,qBADnC,iCACiI,uBAAYA,WAAW,KAAvB,oBADjI,iDAC8O,uBAAYA,WAAW,KAAvB,SAD9O,gBAEA,eACE,GAAM,mDADR,oDAGA,+JACA,kCACA,kTAEA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,65DAwEL,eACE,GAAM,uBADR,wBAGA,8DAA+C,uBAAYA,WAAW,KAAvB,kDAA/C,SAAkJ,uBAAYA,WAAW,KAAvB,sCAAlJ,kBAAkP,uBAAYA,WAAW,KAAvB,4DAAlP,gCAAsX,uBAAYA,WAAW,KAAvB,qBAAtX,iDAKJJ,EAAWK,gBAAiB","sources":["webpack://commerce-php/./src/pages/developer/components/async-operations.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/commerce-php/commerce-php/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`Asynchronous operations are not native to PHP but it is still possible to execute heavy\noperations simultaneously, or delay them until they absolutely have to be finished.`}</p>\n    <p>{`To make writing asynchronous code easier, Adobe Commerce and Magento Open Source provide the `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` to use with asynchronous operations.\nThis allows client code to work with asynchronous operations just as it would with standard operations.`}</p>\n    <h2 {...{\n      \"id\": \"deferredinterface\"\n    }}>{`DeferredInterface`}</h2>\n    <p><inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Async\\\\DeferredInterface`}</inlineCode>{` is quite simple:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`interface DeferredInterface\n{\n    /**\n     * @return mixed Value.\n     * @throws \\\\Throwable\n     */\n    public function get();\n\n    public function isDone(): bool;\n}\n`}</code></pre>\n    <p>{`When the client code needs the result, the `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` method will be called to retrieve the result.\n`}<inlineCode parentName=\"p\">{`isDone()`}</inlineCode>{` can be used to see whether the code has completed.`}</p>\n    <p>{`There are 2 types of asynchronous operations where `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to describe the result:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`With asynchronous operations in progress, calling `}<inlineCode parentName=\"li\">{`get()`}</inlineCode>{` would wait for them to finish and return their result.`}</li>\n      <li parentName=\"ul\">{`With deferred operations, `}<inlineCode parentName=\"li\">{`get()`}</inlineCode>{` would actually start the operation, wait for it to finish, and then return the result.`}</li>\n    </ul>\n    <p>{`Sometimes developers require more control over long asynchronous operations.\nThat is why there is an extended deferred variant - `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Async\\\\CancelableDeferredInterface`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`interface CancelableDeferredInterface extends DeferredInterface\n{\n    /**\n     * @param bool $force Cancel operation even if it's already started.\n     * @return void\n     * @throws CancelingDeferredException When failed to cancel.\n     */\n    public function cancel(bool $force = false): void;\n\n    /**\n     * @return bool\n     */\n    public function isCancelled(): bool;\n}\n`}</code></pre>\n    <p>{`This interface is for operations that may take too long and can be canceled.`}</p>\n    <h3 {...{\n      \"id\": \"client-code\"\n    }}>{`Client code`}</h3>\n    <p>{`Assuming that `}<inlineCode parentName=\"p\">{`serviceA`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`serviceB`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`serviceC`}</inlineCode>{` all execute asynchronous operations, such as HTTP requests, the client code would look like:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function aMethod() {\n    //Started executing 1st operation\n    $operationA = $serviceA->executeOp();\n\n    //Executing 2nd operations at the same time\n    $operationB = $serviceB->executeOp2();\n\n    //We need to wait for 1st operation to start operation #3\n    $serviceC->executeOp3($operationA->get());\n\n    //We don't have to wait for operation #2, let client code wait for it if it needs the result\n    //Operation number #3 is being executed simultaneously with operation #2\n    return $operationB;\n}\n`}</code></pre>\n    <p>{`And not a callback in sight!`}</p>\n    <p>{`With the deferred client, the code can start multiple operations at the same time, wait for operations required to finish and pass the promise of a result to another method.`}</p>\n    <h2 {...{\n      \"id\": \"proxydeferredfactory\"\n    }}>{`ProxyDeferredFactory`}</h2>\n    <p>{`When writing a module or an extension, you may not want to burden other developers with having to know that your method is performing an asynchronous operation.\nThere is a way to hide it: employ the autogenerated factory `}<inlineCode parentName=\"p\">{`YourClassName\\\\ProxyDeferredFactory`}</inlineCode>{`. With its help, you can return values that seem like regular objects\nbut are in fact deferred results.`}</p>\n    <p>{`For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function __construct(CallResult\\\\ProxyDeferredFactory $callResultFactory)\n{\n    $this->proxyDeferredFactory = $callResultFactory;\n}\n\n....\n\npublic function doARemoteCall(string $uniqueValue): CallResult\n{\n    //Async HTTP request, get() will return a CallResult instance.\n    //Call is in progress.\n    $deferredResult = $this->client->call($uniqueValue);\n\n    //Returns CallResult instance that will call $deferredResult->get() when any of the object's methods is used.\n    return $this->proxyDeferredFactory->create(['deferred' => $deferredResult]);\n}\n\npublic function doCallsAndProcess(): Result\n{\n    //Both calls running simultaneously\n    $call1 = $this->doARemoteCall('call1');\n    $call2 = $this->doARemoteCall('call2');\n\n    //Only when CallResult::getStuff() is called the $deferredResult->get() is called.\n    return new Result([\n        'call1' => $call1->getStuff(),\n        'call2' => $call2->getStuff()\n    ]);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"using-deferredinterface-for-background-operations\"\n    }}>{`Using DeferredInterface for background operations`}</h2>\n    <p>{`As mentioned above, the first type of asynchronous operations are operations executing in a background.\n`}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to give client code a promise of a not-yet-received result and wait for it by calling the `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` method.`}</p>\n    <p>{`Take a look at an example: creating shipments for multiple products:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class DeferredShipment implements DeferredInterface\n{\n    private $request;\n\n    private $done = false;\n\n    private $trackingNumber;\n\n    public function __construct(AsyncRequest $request)\n    {\n        $this->request = $request;\n    }\n\n    public function isDone() : bool\n    {\n        return $this->done;\n    }\n\n    public function get()\n    {\n        if (!$this->trackingNumber) {\n            $this->request->wait();\n            $this->trackingNumber = json_decode($this->request->getBody(), true)['tracking'];\n\n            $this->done = true;\n        }\n\n        return $this->trackingNumber;\n    }\n}\n\nclass Shipping\n{\n    ....\n\n    public function ship(array $products): array\n    {\n        $shipments = [];\n        //Shipping simultaneously\n        foreach ($products as $product) {\n            $shipments[] = new DeferredShipment(\n                $this->client->sendAsync(['id' => $product->getId()])\n            );\n        }\n\n        return $shipments;\n    }\n}\n\nclass ShipController\n{\n    ....\n\n    public function execute(Request $request): Response\n    {\n        $shipments = $this->shipping->ship($this->products->find($request->getParam('ids')));\n        $trackingsNumbers = [];\n        foreach ($shipments as $shipment) {\n            $trackingsNumbers[] = $shipment->get();\n        }\n\n        return new Response(['trackings' => $trackingNumbers]);\n    }\n}\n`}</code></pre>\n    <p>{`Here, multiple shipment requests are being sent at the same time with their results gathered later.\nIf you do not want to write your own `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` implementation, you can use `}<inlineCode parentName=\"p\">{`CallbackDeferred`}</inlineCode>{` to provide callbacks that will be used when `}<inlineCode parentName=\"p\">{`get()`}</inlineCode>{` is called.`}</p>\n    <h2 {...{\n      \"id\": \"using-deferredinterface-for-deferred-operations\"\n    }}>{`Using DeferredInterface for deferred operations`}</h2>\n    <p>{`The second type of asynchronous operations are operations that are being postponed and executed only when a result is absolutely needed.`}</p>\n    <p>{`An example:`}</p>\n    <p>{`Assume you are creating a repository for an entity and you have a method that returns a singular entity by ID.\nYou want to make a performance optimization for cases when multiple entities are requested during the same request-response process, so you would not load them separately.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class EntityRepository\n{\n    private $requestedEntityIds = [];\n\n    private $identityMap = [];\n\n    ...\n\n    /**\n     * @return Entity[]\n     */\n    public function findMultiple(array $ids): array\n    {\n        .....\n\n        //Adding found entities to the identity map be able to find them by ID.\n        foreach ($found as $entity) {\n            $this->identityMap[$entity->getId()] = $entity;\n        }\n\n        ....\n    }\n\n    public function find(string $id): Entity\n    {\n        //Adding this ID to the list of previously requested IDs.\n        $this->requestedEntityIds[] = $id;\n\n        //Returning deferred that will find all requested entities\n        //and return the one with $id\n        return $this->proxyDeferredFactory->createFor(\n            Entity::class,\n            new CallbackDeferred(\n                function () use ($id) {\n                    if (empty($this->identityMap[$id])) {\n                        $this->findMultiple($this->requestedEntityIds);\n                        $this->requestedEntityIds = [];\n                    }\n\n                    return $this->identityMap[$id];\n                }\n            )\n        );\n    }\n\n    ....\n}\n\nclass EntitiesController\n{\n    ....\n\n    public function execute(): Response\n    {\n        //No actual DB query issued\n        $criteria1Id = $this->entityService->getEntityIdWithCriteria1();\n        $criteria2Id = $this->entityService->getEntityIdWithCriteria2();\n        $criteria1Entity = $this->entityRepo->find($criteria1Id);\n        $criteria2Entity = $this->entityRepo->find($criteria2Id);\n\n        //Querying the DB for both entities only when getStringValue() is called the 1st time.\n        return new Response(\n            [\n                'criteria1' => $criteria1Entity->getStringValue(),\n                'criteria2' => $criteria2Entity->getStringValue()\n            ]\n        );\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"examples-in-magento\"\n    }}>{`Examples in Magento`}</h2>\n    <p>{`Please see our asynchronous HTTP client `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\HTTP\\\\AsyncClientInterface`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Magento\\\\Shipping\\\\Model\\\\Shipping`}</inlineCode>{` with various `}<inlineCode parentName=\"p\">{`Magento\\\\Shipping\\\\Model\\\\Carrier\\\\AbstractCarrierOnline`}</inlineCode>{` implementations to see how `}<inlineCode parentName=\"p\">{`DeferredInterface`}</inlineCode>{` can be used to work with asynchronous code.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}