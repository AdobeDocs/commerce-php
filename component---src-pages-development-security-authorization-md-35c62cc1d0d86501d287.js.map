{"version":3,"file":"component---src-pages-development-security-authorization-md-35c62cc1d0d86501d287.js","mappings":"6QAQaA,EAAe,GACtBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,SAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,iBADR,kBAGA,eACE,GAAM,qCADR,sCAGA,2QACA,eACE,GAAM,qBADR,wBAGA,oBACE,eAAIC,WAAW,OACb,cAAGA,WAAW,MAAd,6BACA,cAAGA,WAAW,MAAd,2HACC,uBAAYA,WAAW,KAAvB,4CADD,gBAEA,cAAGA,WAAW,MAAd,iFACN,uBAAYA,WAAW,KAAvB,yDADM,iBAGF,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAd,0DACA,cAAGA,WAAW,MAAd,2NAEM,uBAAYA,WAAW,KAAvB,iCAFN,sBAEqG,uBAAYA,WAAW,KAAvB,kBAFrG,+CAKJ,eACE,GAAM,iCADR,mCAGA,kFAAmE,uBAAYA,WAAW,KAAvB,cAAnE,sDACA,uBAAYA,WAAW,KAAvB,SADA,qDACsG,uBAAYA,WAAW,KAAvB,YADtG,aACuK,uBAAYA,WAAW,KAAvB,0BADvK,WAEA,iGACA,oBACE,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAd,gCACN,uBAAYA,WAAW,KAAvB,qCAEI,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAd,kCACN,uBAAYA,WAAW,KAAvB,gCAEI,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAd,2EAA8F,uBAAYA,WAAW,KAAvB,YAA9F,YACN,uBAAYA,WAAW,KAAvB,+CADM,MAEN,uBAAYA,WAAW,KAAvB,mDAGE,eACE,GAAM,iBADR,kBAGA,0IACK,uBAAYA,WAAW,KAAvB,oBADL,SAC0E,uBAAYA,WAAW,KAAvB,8BAD1E,4BAEA,0GAA2F,uBAAYA,WAAW,KAAvB,eAA3F,8EACkD,uBAAYA,WAAW,KAAvB,yBADlD,MAEA,mDAAoC,uBAAYA,WAAW,KAAvB,eAApC,oJACuF,uBAAYA,WAAW,KAAvB,cADvF,gDAGA,eACE,GAAM,0BADR,2BAGA,yHACA,eACE,GAAM,+CADR,kDAGA,0BAAW,uBAAYA,WAAW,KAAvB,wBAAX,8DACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,osBAsBL,eACE,GAAM,4CADR,6CAGA,wBAAS,uBAAYA,WAAW,KAAvB,oDAAT,iGACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,qjBAoBL,eACE,GAAM,0BADR,2BAGA,8SAGA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,iQASL,eACE,GAAM,oEADR,qEAGA,oOAEA,mKACuB,uBAAYA,WAAW,KAAvB,eADvB,iVAIM,uBAAYA,WAAW,KAAvB,eAJN,gLAMA,eACE,GAAM,0BADR,2BAGA,sqBAKA,6iCASA,yUAEuE,uBAAYA,WAAW,KAAvB,gDAFvE,gDAIA,0CAA2B,uBAAYA,WAAW,KAAvB,uBAA3B,qCACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,k2EA6FTJ,EAAWK,gBAAiB","sources":["webpack://commerce-php/./src/pages/development/security/authorization.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/commerce-php/commerce-php/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"authorization\"\n    }}>{`Authorization`}</h1>\n    <h2 {...{\n      \"id\": \"configuration-based-authorization\"\n    }}>{`Configuration-based authorization`}</h2>\n    <p>{`Through configuration, Adobe Commerce and Magento Open Source provide a number of ways to mark a page (controller) or an endpoint as accessible to guests, logged in customers, or administrators with roles that allow access to certain resources.`}</p>\n    <h3 {...{\n      \"id\": \"pages-controllers\"\n    }}>{`Pages (controllers)`}</h3>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Distinction by user type`}</p>\n        <p parentName=\"li\">{`To make a page accessible to customers (both guests and registered) coming from storefront, place a controller\nin the `}<inlineCode parentName=\"p\">{`<Vendor>\\\\\\\\<Module>\\\\\\\\Controller\\\\\\\\**`}</inlineCode>{` namespace.`}</p>\n        <p parentName=\"li\">{`To make a page accessible only to administrators, place a controller in the\n`}<inlineCode parentName=\"p\">{`<Vendor>\\\\\\\\<Module>\\\\\\\\Controller\\\\\\\\Adminhtml\\\\\\\\**`}</inlineCode>{` namespace.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Requiring specific resource access for administrators`}</p>\n        <p parentName=\"li\">{`Each administrator is assigned an ACL role that provides them access only to selected resources.\nTo mark your page (route/controller) as one that requires access to a specific resource, the controller\nmust extend `}<inlineCode parentName=\"p\">{`Magento\\\\Backend\\\\App\\\\Action`}</inlineCode>{` and override the `}<inlineCode parentName=\"p\">{`ADMIN_RESOURCE`}</inlineCode>{` constant with the name of the resource.`}</p>\n      </li>\n    </ul>\n    <h3 {...{\n      \"id\": \"restfulsoap-web-api-endpoints\"\n    }}>{`RESTful/SOAP web API endpoints`}</h3>\n    <p>{`RESTful/SOAP web API endpoints are configured in a module's `}<inlineCode parentName=\"p\">{`webapi.xml`}</inlineCode>{` configuration file. An endpoint is defined as\na `}<inlineCode parentName=\"p\">{`route`}</inlineCode>{` tag and authorization for each is configured by `}<inlineCode parentName=\"p\">{`resource`}</inlineCode>{` tags in `}<inlineCode parentName=\"p\">{`routes.route.resources`}</inlineCode>{` path.`}</p>\n    <p>{`Endpoints can be configured to be accessible by specific users as follows:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`For guest customer access:\n`}<inlineCode parentName=\"p\">{`<resource>anonymous</resource>`}</inlineCode></p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`For authenticated customers:\n`}<inlineCode parentName=\"p\">{`<resource>self</resource>`}</inlineCode></p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`For administrators or 3rd-party integration clients by one or multiple `}<inlineCode parentName=\"p\">{`resource`}</inlineCode>{` tags:\n`}<inlineCode parentName=\"p\">{`<resource>Module_Name::resource1</resource>`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`<resource>Module_Name::resource2</resource>`}</inlineCode></p>\n      </li>\n    </ul>\n    <h3 {...{\n      \"id\": \"ui-components\"\n    }}>{`UI components`}</h3>\n    <p>{`To mark UI components as accessible by customers or administrators, place the UI component XML config files\nin the `}<inlineCode parentName=\"p\">{`<Module>/view/**`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`<Module>/view/adminhtml/**`}</inlineCode>{` folders, respectively.`}</p>\n    <p>{`To require specific ACL resource access for administrators, UI component tags allow `}<inlineCode parentName=\"p\">{`aclResource`}</inlineCode>{` tags and attributes\naccepting string values with resource names such as `}<inlineCode parentName=\"p\">{`Module_Name::resource`}</inlineCode>{`.`}</p>\n    <p>{`It is important to provide a `}<inlineCode parentName=\"p\">{`aclResource`}</inlineCode>{` configuration when a UI component (or data provider)\nexposes sensitive information, since any UI component can be rendered on its own through `}<inlineCode parentName=\"p\">{`mui/render`}</inlineCode>{` without\ngoing through a controller first.`}</p>\n    <h2 {...{\n      \"id\": \"explicit-authorization\"\n    }}>{`Explicit authorization`}</h2>\n    <p>{`However, some cases cannot be covered by configuration. Authorization must be verified explicitly.`}</p>\n    <h3 {...{\n      \"id\": \"page-controller-for-authenticated-customers\"\n    }}>{`Page (controller) for authenticated customers`}</h3>\n    <p>{`The `}<inlineCode parentName=\"p\">{`UserContextInterface`}</inlineCode>{` can be utilized to verify that a customer has logged in:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class MyController implements \\\\Magento\\\\Framework\\\\App\\\\ActionInterface, \\\\Magento\\\\Framework\\\\App\\\\Action\\\\HttpGetActionInterface {\n    private \\\\Magento\\\\Authorization\\\\Model\\\\UserContextInterface $userContext;\n    ...\n    public function construct(\\\\Magento\\\\Authorization\\\\Model\\\\UserContextInterface $userContext) {\n        $this->userContext = $userContext;\n    }\n    ...\n\n    public function execute() {\n        ...\n\n        if ($this->userContext->getUserType() == UserContextInterface::USER_TYPE_CUSTOMER\n            && $this->userContext->getUserId()) {\n            ...\n        } else {\n            throw new AuthorizationException(__('Please log in'));\n        }\n    }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"graphql-node-for-authenticated-customers\"\n    }}>{`GraphQL node for authenticated customers`}</h3>\n    <p>{`A `}<inlineCode parentName=\"p\">{`Magento\\\\GraphQl\\\\Model\\\\Query\\\\ContextInterface`}</inlineCode>{` instance is always available for GraphQL resolvers and can help with authorizing customers.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class MyResolver implements \\\\Magento\\\\Framework\\\\GraphQl\\\\Query\\\\ResolverInterface\n{\n    ...\n    public function resolve(\n        Field $field,\n        $context,\n        ResolveInfo $info,\n        array $value = null,\n        array $args = null\n    ) {\n        /** @var \\\\Magento\\\\GraphQl\\\\Model\\\\Query\\\\ContextInterface $context */\n        if (false === $context->getExtensionAttributes()->getIsCustomer()) {\n            throw new GraphQlAuthorizationException(__('The current customer isn\\\\'t authorized.'));\n        }\n        ...\n    }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"ownership-verification\"\n    }}>{`Ownership verification`}</h3>\n    <p>{`There are cases when you want to limit read/write access to information to a user who owns the related entities.\nFor instance, customers must have access only to their own wishlists. When serving this type of information or accepting an update,\nmanual verification is required.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`if ($userContext->getUserType() === UserContextInterface::USER_TYPE_CUSTOMER\n    && $userContext->getUserId() === $wishListItem->getCustomerId()) {\n    return $wishListItem;\n} else {\n    throw new AuthorizationException(__('Not authorized'));\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"explicit-authorization-in-blocks-and-ui-component-data-providers\"\n    }}>{`Explicit authorization in blocks and UI component data providers`}</h3>\n    <p>{`When explicit authorization is required for tasks such as ownership verification, it is important to remember\nthat blocks and UI components can be used with different controllers or rendered on their own.`}</p>\n    <p>{`Consider the example above: you have a page that is supposed to display a specific wishlist. The URL for this page\nhas a required parameter `}<inlineCode parentName=\"p\">{`wishlist_id`}</inlineCode>{`. Inside the controller, you verify ownership before moving forward with\nrendering. But, inside the block or the UI component data provider that is supposed to fetch the wishlist data and\nrender it, you simply find the data by ID. This particular page will be protected but when the UI component is rendered independently\nthrough `}<inlineCode parentName=\"p\">{`/mui/render`}</inlineCode>{`, or when the block is used on a different page with a different controller, no ownership authorization will occur,\nand any wishlist data may be retrieved through the ID.`}</p>\n    <h2 {...{\n      \"id\": \"temporal-authorization\"\n    }}>{`Temporal authorization`}</h2>\n    <p>{`There are cases where it is either impossible to authorize a user via login/password, or access to a resource must\nbe issued temporarily. For instance, when a protected page needs to be accessible from an e-mail link immediately without\nrequiring the user to have a valid session or go through sign-up/login. For situations such as this, a self-signed token with a\nlimited lifespan can be utilized. Self-signed tokens have advantages over randomized secrets stored in the database in that you do not\nhave to store them and maintain their lifespan. They can be verified without accessing storage and the TTL information that is embedded inside of them.`}</p>\n    <p>{`Let's take the \"page accessible from e-mail\" example. Imagine that there is a requirement to remind customers that have\nnot finished registration to complete the process. Your store needs to send such customers an e-mail with a link\nto a sign-up form with fields containing previously entered information. These customers cannot login, and it cannot be\nexpected for them to have the same session cookie when they follow the e-mail link. This issue can be solved by\nembedding a self-signed token inside the link that contains the \"unfinished sign up data\" ID and expiration datetime\nto protect the token from brute force attack. Then when customer follows the link, the store would verify its\nsignature or decrypt it, verify that token has not yet expired, and then pre-fill the form with customer data retrieved from\nthe database by ID. If the form is not too big, then it would be possible to even avoid storing data in persistent storage, but\ninstead embed it inside the token itself using an encrypted token to protect sensitive data.`}</p>\n    <p>{`When the only client of a self-signed token is the application itself, it is not absolutely necessary to follow\na certain standard when generating self-signed tokens, but it would be easier and more secure to utilize one, like JWT.\nThe application framework provides a tool to help with this process. See `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Jwt\\\\JwtManagerInterface`}</inlineCode>{`\nand its usage within Magento Open Source.`}</p>\n    <p>{`An example of using `}<inlineCode parentName=\"p\">{`JwtManagerInterface`}</inlineCode>{` for the e-mail link case above:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`class FinishSignUpTokenManager {\n  ...\n\n  private JwtManagerInterface $jwtManager;\n\n  private EncryptionSettingsInterface $jwtEncSettings;\n\n  private string $secret;\n\n  public function construct(JwtManagerInterface $jwtManager, JwkFactory $jwtFactory, string $secret) {\n    $this->jwtManager = $jwtManager;\n    //Configure JWT encryption settings\n    $this->jwtEncSettings = new JweEncryptionJwks(\n      $jwkFactory->createA128KW($secret),\n      JweEncryptionSettingsInterface::CONTENT_ENCRYPTION_ALGO_A128_HS256\n    );\n  }\n\n  public function generate(SignUpFormData $data): string {\n    //Embed signUp data array into JWT claims\n    $jwt = new Jwe(\n      new JweHeader([]),\n      new ClaimsPayload(\n        [\n          new PrivateHeaderParameter('signup-data', $data->getData()),\n          new ExpirationTime((new \\\\DateTimeImmutable())->add(new \\\\DateInterval('P7D')))\n        ]\n      )\n    );\n\n    return $this->jwtManager->create($jwt, $this->jwtEncSettings);\n  }\n\n  public function readToken(string $token): SignUpFormData\n  {\n    $jwt = $this->jwtManager->read($token, $this->jwtEncSettings);\n    /** @var ClaimsPayloadInterface $payload */\n    $payload = $jwt->getPayload();\n    if ($payload instanceof ClaimsPayloadInterface) {\n      if (((int) $payload->getClaims()['exp']->getValue()) <= time()) {\n        throw new LocalizedException(__('Token expired'));\n      }\n\n      return new SignUpFormData($payload->getClaims()['signup-data']->getValue());\n    } else {\n      throw new LocalizedException(__('Invalid token'));\n    }\n  }\n}\n\nclass FinishSignUpNotifier {\n  ...\n\n  private FinishSignUpTokenManager $tokenManager;\n\n  ...\n\n  public function notify(SignUpFormData $data) {\n    ...\n\n    //Generating link for E-mails\n    $link .= '?token=' .$this->tokenManager->generate($data);\n\n    ...\n  }\n}\n\nclass SignUp implements ActionInterface, HttpPostActionInterface {\n  ...\n\n  private FinishSignUpTokenManager $tokenManager;\n\n  ...\n\n  public function execute() {\n    //Retrieving previously filled data from token inside the controller to display SignUp form\n    try {\n      $signUpPrefilled = $this->tokenManager->readToken($this->request->getParam('token'));\n    } catch (LocalizedException $ex) {\n      $signUpPrefilled = null;\n      $this->messages->addWarning($ex->getPhrase());\n    }\n\n    ...\n  }\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}